const prisma = require('../lib/database');

class PromptService {
  /**
   * Get all prompts
   */
  async getAllPrompts() {
    return await prisma.prompt.findMany({
      where: { isActive: true },
      orderBy: [
        { isBuiltin: 'desc' }, // Built-in prompts first
        { name: 'asc' }
      ],
      select: {
        id: true,
        name: true,
        description: true,
        isBuiltin: true,
        createdAt: true,
        usageCount: true,
        lastUsedAt: true
      }
    });
  }

  /**
   * Get a specific prompt by name
   */
  async getPromptByName(name) {
    const prompt = await prisma.prompt.findUnique({
      where: { name },
      include: {
        versions: {
          orderBy: { version: 'desc' },
          take: 5 // Last 5 versions
        }
      }
    });

    if (!prompt) {
      throw new Error(`Prompt "${name}" not found`);
    }

    // Update usage tracking
    await this.updateUsageStats(prompt.id);

    return prompt;
  }

  /**
   * Create a new prompt
   */
  async createPrompt(data) {
    const { name, baseRules, formConfig, model, temperature, description, createdBy } = data;

    // Check if prompt already exists
    const existing = await prisma.prompt.findUnique({
      where: { name }
    });

    if (existing) {
      throw new Error(`Prompt "${name}" already exists`);
    }

    // Create prompt with initial version
    const prompt = await prisma.prompt.create({
      data: {
        name,
        baseRules,
        formConfig,
        model: model || 'gpt-4o-mini',
        temperature: temperature || 0.2,
        description,
        createdBy,
        versions: {
          create: {
            version: 1,
            baseRules,
            formConfig,
            createdBy,
            changeNotes: 'Initial version'
          }
        }
      },
      include: {
        versions: true
      }
    });

    return prompt;
  }

  /**
   * Update an existing prompt
   */
  async updatePrompt(name, data) {
    const { baseRules, formConfig, model, temperature, description, createdBy, changeNotes } = data;

    const existingPrompt = await prisma.prompt.findUnique({
      where: { name },
      include: {
        versions: {
          orderBy: { version: 'desc' },
          take: 1
        }
      }
    });

    if (!existingPrompt) {
      throw new Error(`Prompt "${name}" not found`);
    }

    // Check if this is actually a change
    const lastVersion = existingPrompt.versions[0];
    const hasChanges = lastVersion.baseRules !== baseRules || 
                      JSON.stringify(lastVersion.formConfig) !== JSON.stringify(formConfig);

    if (!hasChanges) {
      return existingPrompt; // No changes needed
    }

    // Create new version and update prompt
    const newVersion = lastVersion.version + 1;

    const updatedPrompt = await prisma.prompt.update({
      where: { name },
      data: {
        baseRules,
        formConfig,
        model: model || existingPrompt.model,
        temperature: temperature !== undefined ? temperature : existingPrompt.temperature,
        description: description !== undefined ? description : existingPrompt.description,
        updatedAt: new Date(),
        versions: {
          create: {
            version: newVersion,
            baseRules,
            formConfig,
            createdBy,
            changeNotes: changeNotes || `Updated to version ${newVersion}`
          }
        }
      },
      include: {
        versions: {
          orderBy: { version: 'desc' },
          take: 5
        }
      }
    });

    return updatedPrompt;
  }

  /**
   * Delete a prompt
   */
  async deletePrompt(name) {
    const prompt = await prisma.prompt.findUnique({
      where: { name }
    });

    if (!prompt) {
      throw new Error(`Prompt "${name}" not found`);
    }

    if (prompt.isBuiltin) {
      throw new Error(`Cannot delete built-in prompt "${name}"`);
    }

    await prisma.prompt.delete({
      where: { name }
    });

    return { success: true, message: `Prompt "${name}" deleted successfully` };
  }

  /**
   * Update usage statistics
   */
  async updateUsageStats(promptId) {
    await prisma.prompt.update({
      where: { id: promptId },
      data: {
        usageCount: { increment: 1 },
        lastUsedAt: new Date()
      }
    });
  }

  /**
   * Generate JavaScript module code for a prompt (for backwards compatibility)
   */
  generateModuleCode(prompt) {
    const { name, model, temperature, baseRules, formConfig } = prompt;
    
    const safeBaseRules = baseRules.replace(/`/g, '\\`');
    const metadataComment = formConfig 
      ? `// Form metadata: ${JSON.stringify(formConfig)}`
      : '// No form metadata available';

    return `
// AUTO-GENERATED by /api/prompt-versions
${metadataComment}
module.exports = {
  name: "${name}",
  model: process.env.OPENAI_MODEL || "${model}",
  temperature: ${temperature},
  useJsonMode: true,
  // Form metadata for editing (if available)
  _formMetadata: ${formConfig ? JSON.stringify(formConfig) : 'null'},
  buildMessages({ text, role, company, jdInfo = {}, jdRaw = "", links = [] }) {
    const schema = \`{
  "name": string | null,
  "contact": { "email": string | null, "phone": string | null },
  "summary": string | null,
  "experience": [
    { "title": string | null, "company": string | null, "dates": string | null, "bullets": string[] }
  ],
  "education": [
    { "degree": string | null, "school": string | null, "dates": string | null }
  ],
  "skills": string[]
}\`;

    const baseRules = \`${safeBaseRules}\`;

    const jdSummary = JSON.stringify({
      title: jdInfo.title || "",
      must: jdInfo.must || [],
      nice: jdInfo.nice || [],
      skills: jdInfo.skills || [],
      tools: jdInfo.tools || [],
      certs: jdInfo.certs || [],
      keywords: jdInfo.keywords || [],
    }, null, 2);

    const linksBlock = (Array.isArray(links) && links.length)
      ? "\\nLinks (reference only; do NOT add to JSON):\\n" + links.slice(0,20).map(x => "- " + x).join("\\n") + "\\n"
      : "";

    const system = baseRules.replace(/\\\${schema}/g, schema);

    const user = \`
Target Role: \${role || ""}
Target Company: \${company || ""}

Job Description (raw, optional):
\${jdRaw || "(none provided)"}

JD Summary (prioritize wording; do NOT invent facts):
\${jdSummary}
\${linksBlock}
---BEGIN RESUME TEXT---
\${text}
---END RESUME TEXT---
\`.trim();

    return [
      { role: "system", content: system },
      { role: "user", content: user },
    ];
  },
};
`.trimStart();
  }
}

module.exports = new PromptService();